# Android之进程与线程

## Android进程的基本知识

当一个应用程序启动的时候，Android会启动一个linux进程和一个主线程。在默认情况下，所有该程序的组件都将在这个进程和线程中运行。同时，Android系统会为每个应用程序分配一个LINUX用户。当系统内存出现不足的时候，Android会尝试停止一些进程从而释放资源给其他优先级高的进程使用，也能保证当前进程有足够的资源以便及时的响应用户事件。

我们将一些组件运行在进程中。组件运行在哪个进程中是在manifes中设置，比如：&lt;activity&gt;，&lt;service&gt;、&lt;recevier&gt;、&lt;provider&gt;都有一个process属性来指定组件运行在哪个进程中。

Android中的所有组件都在指定的进程中的主线程中实例化。对组件的系统调用也是有主线程发出的。Android会根据进程中运行的组件类别和状态来判断进程的重要性。Android会首先停止那些不重要的进程。从高到低：

1. 前台进程
   > 前台进程是用户当前正在使用的进程。只有一些前台进程可以在任何时候都存在。他们是最后一个被结束的，当内存低到根本连他们都不能运行的时候。一般来说， 在这种情况下，设备会进行内存调度，中止一些前台进程来保持对用户交互的响应。
   >
   > 如果有以下的情形的那么就是前台进程：
   >
   > 这个进程运行着一个正在和用户交互的Activity（这个Activity的onResume\(\)方法被调用）。
   >
   > 这个进程里有绑定到当前正在和用户交互的确Activity的一个service。
   >
   > 这个进程里有一个service对象，这个service对象正在执行一个它的生命周期的回调函数\(onCreate\(\), onStart\(\), onDestroy\(\)\)
   >
   > 这个进程里有一个正在的onReceive\(\)方法的BroadCastReiver对象。
2. 可见进程
   > 可见进程不包含前台的组件但是会在屏幕上显示一个可见的进程是的重要程度很高，除非前台进程需要获取它的资源，不然不会被中止。
   >
   > 如果有如下的一种情形就是可见进程：
   >
   > 这个进程中含有一个不位于前台的Activity，但是仍然对用户是可见的\(这个Activity的onPause\(\)方法被调用\)，这是很可能发生的，例如，如果前台进程是一个Activity且是一个对话框的话，就会允许在它后面看到前一个进程的Activity。
   >
   > 这个进程里有一个绑定到一个可见的Activity的Service。
3. 服务进程
   > 运行着一个通过startService\(\) 方法启动的service，这个service不属于上面提到的2种更高重要性的。service所在的进程虽然对用户不是直接可见的，但是他们执行了用户非常关注的任务（比如播放mp3，从网络下载数据）。只要前台进程和可见进程有足够的内存，系统不会回收他们。
4. 后台进程
   > 运行着一个对用户不可见的activity（调用过 onStop\(\) 方法\).这些进程对用户体验没有直接的影响，可以在服务进程、可见进程、前台进 程需要内存的时候回收。通常，系统中会有很多不可见进程在运行，他们被保存在LRU \(least recently used\) 列表中，以便内存不足的时候被第一时间回收。如果一个activity正 确的执行了它的生命周期，关闭这个进程对于用户体验没有太大的影响。
5. 空进程
   > 未运行任何程序组件。运行这些进程的唯一原因是作为一个缓存，缩短下次程序需要重新使用的启动时间。系统经常中止这些进程，这样可以调节程序缓存和系统缓存的平衡。

## 单线程模型

线程在代码是使用标准的java Thread对象来建立，那么在Android系统中提供了一系列方便的类来管理线程——Looper用来在一个线程中执行消息循环，Handler用来处理消息，HandlerThread创建带有消息循环的线程。具体可以看下面的详细介绍。

当一个程序第一次启动时，Android会同时启动一个对应的主线程（Main Thread），主线程主要负责处理与UI相关的事件，如用户的按键事件，用户接触屏幕的事件以及屏幕绘图事件，并把相关的事件分发到对应的组件进行处理。所以主线程通常又被叫做UI线程。

在开发Android应用时必须遵守单线程模型的原则： Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行。

**子线程更新UI Android的UI是单线程\(Single-threaded\)的。**

为了避免拖住GUI，一些较费时的对象应该交给独立的线程去执行。如果幕后的线程来执行UI对象，Android就会发出错误讯息 CalledFromWrongThreadException。以后遇到这样的异常抛出时就要知道怎么回事了！

